<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>ROTM Admin Dashboard</title>
<style>
body { font-family: Arial; background:#111; color:#fff; padding:20px; max-width:1200px; margin:auto; }
h1, h2 { text-align:center; }
table { width:100%; border-collapse:collapse; margin-top:20px; }
th, td { border:1px solid #555; padding:10px; text-align:center; }
th { background:#333; }
tr.top1 { background:#d4af37; color:#111; font-weight:bold; }
tr.top2 { background:#c0c0c0; color:#111; font-weight:bold; }
tr.top3 { background:#cd7f32; color:#111; font-weight:bold; }
button { margin-top:20px; padding:10px 20px; font-size:16px; cursor:pointer; }
.tab-buttons { text-align:center; margin-top:20px; }
.tab-buttons button { margin:0 5px; }
#resetButton { background-color: #c0392b; color: white; border: none; }
.tab { display:none; }
.tab.active { display:block; }
</style>
</head>
<body>
<h1>ROTM Admin Dashboard</h1>

<div class="tab-buttons">
  <button id="scoresTabBtn">Scores</button>
  <button id="votesTabBtn">Detailed Votes</button>
  <button id="resetButton">Reset All Votes</button>
</div>

<div id="scoresTab" class="tab active">
  <table id="rankingTable">
    <thead>
      <tr>
        <th>Rank</th>
        <th>Video Title</th>
        <th>Reddit Upvotes</th>
        <th>Upvote Points</th>
        <th>Vote Points</th>
        <th>Total Score</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>
</div>

<div id="votesTab" class="tab">
  <table id="votesTable">
    <thead>
      <tr>
        <th>User ID</th>
        <th>Rank 1</th>
        <th>Rank 2</th>
        <th>Rank 3</th>
        <th>Timestamp</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>
</div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js";
import { getFirestore, collection, onSnapshot, getDocs, deleteDoc } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyDChk83uv5LqXHemAziEHO3YAqEROHjIbo",
  authDomain: "rotm-2a088.firebaseapp.com",
  projectId: "rotm-2a088"
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

// Tab and button elements
const scoresTabBtn = document.getElementById("scoresTabBtn");
const votesTabBtn = document.getElementById("votesTabBtn");
const scoresTab = document.getElementById("scoresTab");
const votesTab = document.getElementById("votesTab");
const resetButton = document.getElementById("resetButton"); 

scoresTabBtn.addEventListener("click", () => { scoresTab.classList.add("active"); votesTab.classList.remove("active"); });
votesTabBtn.addEventListener("click", () => { votesTab.classList.add("active"); scoresTab.classList.remove("active"); });

const videosCol = collection(db, "videos");
const votesCol = collection(db, "votes");

let videosData = {};
let votesData = [];
let videosLoaded = false;
let votesLoaded = false;

// Listeners
onSnapshot(videosCol, snapshot => {
  const newVideosData = {};
  snapshot.docs.forEach(doc => {
    newVideosData[doc.id] = { ...doc.data() };
  });
  videosData = newVideosData;
  videosLoaded = true;
  if (votesLoaded) calculateScores();
});

onSnapshot(votesCol, snapshot => {
  votesData = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
  votesLoaded = true;
  if (videosLoaded) calculateScores();
  renderVotes();
});

// =================================================================
// COMPLETELY REWRITTEN SCORING LOGIC FOR RELIABILITY
// =================================================================
function calculateScores() {
  if (!videosLoaded || !votesLoaded || Object.keys(videosData).length === 0) return;

  // Step 1: Create a temporary map to safely store calculated points.
  // This avoids modifying the main data object while iterating.
  const pointsMap = {};
  Object.keys(videosData).forEach(videoId => {
    pointsMap[videoId] = { votePoints: 0 };
  });

  // Step 2: Iterate through all votes and populate the temporary points map.
  votesData.forEach(vote => {
    if (vote.rank1 && pointsMap[vote.rank1]) {
      pointsMap[vote.rank1].votePoints += 100;
    }
    if (vote.rank2 && pointsMap[vote.rank2]) {
      pointsMap[vote.rank2].votePoints += 50;
    }
    if (vote.rank3 && pointsMap[vote.rank3]) {
      pointsMap[vote.rank3].votePoints += 25;
    }
  });

  // Step 3: Safely merge the calculated vote points back into the main videosData object.
  Object.keys(videosData).forEach(videoId => {
    videosData[videoId].votePoints = pointsMap[videoId].votePoints || 0;
  });

  // Step 4: Calculate upvote points.
  const sortedByUpvotes = Object.values(videosData).slice().sort((a, b) => a.upvotes - b.upvotes);
  const step = 10;
  sortedByUpvotes.forEach((video, index) => {
    // We need to find the video in the original videosData to assign the points,
    // as sorting creates a new array order.
    const originalVideo = Object.values(videosData).find(v => v.title === video.title);
    if(originalVideo) {
      originalVideo.upvotePoints = step * (index + 1);
    }
  });

  // Step 5: Calculate the final total score for each video.
  Object.values(videosData).forEach(video => {
    video.totalScore = (video.votePoints || 0) + (video.upvotePoints || 0);
  });

  // Step 6: Render the updated table.
  renderRanking();
}

function renderRanking() {
  const tbody = document.querySelector("#rankingTable tbody");
  tbody.innerHTML = "";
  const sorted = Object.values(videosData).sort((a,b) => b.totalScore - a.totalScore);
  sorted.forEach((v,i) => {
    const tr = document.createElement("tr");
    if(i===0) tr.classList.add("top1");
    else if(i===1) tr.classList.add("top2");
    else if(i===2) tr.classList.add("top3");
    tr.innerHTML = `
      <td>${i+1}</td>
      <td>${v.title}</td>
      <td>${v.upvotes || 0}</td>
      <td>${v.upvotePoints || 0}</td>
      <td>${v.votePoints || 0}</td>
      <td>${v.totalScore || 0}</td>
    `;
    tbody.appendChild(tr);
  });
}

function renderVotes() {
  const tbody = document.querySelector("#votesTable tbody");
  tbody.innerHTML = "";
  if(!votesData || votesData.length === 0 || Object.keys(videosData).length === 0) return;

  const sortedVotes = votesData.slice().sort((a, b) => (b.timestamp?.seconds || 0) - (a.timestamp?.seconds || 0));

  sortedVotes.forEach(v => {
    const tr = document.createElement("tr");
    const ts = v.timestamp && v.timestamp.seconds ? new Date(v.timestamp.seconds * 1000).toLocaleString() : "";
    tr.innerHTML = `
      <td>${v.userId || ""}</td>
      <td>${v.rank1 ? videosData[v.rank1]?.title || v.rank1 : ""}</td>
      <td>${v.rank2 ? videosData[v.rank2]?.title || v.rank2 : ""}</td>
      <td>${v.rank3 ? videosData[v.rank3]?.title || v.rank3 : ""}</td>
      <td>${ts}</td>
    `;
    tbody.appendChild(tr);
  });
}

resetButton.addEventListener('click', async () => {
  if (!confirm("Are you sure you want to permanently delete ALL votes? This action cannot be undone.")) {
    return;
  }
  try {
    const querySnapshot = await getDocs(votesCol);
    const deletePromises = querySnapshot.docs.map(doc => deleteDoc(doc.ref));
    await Promise.all(deletePromises);
    alert("All votes have been successfully reset.");
  } catch (error) {
    console.error("Error removing documents: ", error);
    alert("Failed to reset votes. Check the console for errors.");
  }
});
</script>
</body>
</html>
